---
title: "Ты не упомянул строки"
date: 2023-05-20
draft: false
---

Эксперементальный заметк. Она продолжает изменяться и дополняться.
Все правки, очепятки и откровенные ошибки вы можете отправлять на электронный
адрес rokkerruslan@protonmail.com, я пофикшу это. Так же можно внести правки
самостоятельно через [Pull Request](https://github.com/rokkerruslan/gobuch/pulls).
Буду рад. Стараюсь как могу не сильно глубоко уходить в детали и не
расспыляться по многим темам одновременно чтобы сохранить некоторую целостность
в повествовании и темп рассказа. Сноски содержат более подробное описание
блока, его пояснение (или ещё больше запутывают). По ним можно проходить чтобы
понять что имелось в виду в том или ином пункте, если этот пункт в статье
показался неочевидным. Так же сноски содержат ссылки на дополнительные источники
информации [^7].

```
go env GOVERSION GOARCH GOOS
devel go1.22-460dc37c88 Sat Aug 6 12:00:00 2042 +0000
amd64
linux
```

## Чсть 1

Парсинг это одна из самых распространённых задач в программировании. Пример
с которого мы начнём не будет отличаться оригинальностью или вычурнутостью.
Он вполне банален, есть массив байт, нужно преобразовать его в число, массивы 
байт будут содержать закодированные [utf-8](https://en.wikipedia.org/wiki/UTF-8),
целые, неотрицательные, 64-битные числа в десятеричной системе счисления.

```go
package main

func main() {
	l := []byte{0x31, 0x32, 0x33} // 1 2 3
	println(string(l))
}

// go run main.go
// 123
```

Структура данных представляющая последовательность байт в языке Go это [Array]
(https://go.dev/ref/spec#Array_types) и реализованный на базе `Array` тип
[Slice](https://go.dev/ref/spec#Slice_types), `Slice` имеет чуть больше
возможностей и концептуально не отличается от `Array`, будем использовать `Slice` имеющий более широкое распространение в пользовательском коде.
С типами входных данных определились, едём дальше. Алгоритм.

Выделяем некоторое место buf. На каждой итерации цикла копируем из источника данные в buf,
обрабатываем их, проводя некие вычисления с текущим состоянием buf. В первом приближении
решение будет выглядеть так:

```go
// allocate buf
// loop
	n, err := source.ReadFrom(buf[:])
	// ...
	nn, err := strconv.ParseUint(buf[:n], 10, 64)
	// ...
```

Хорошо, но этот код не компилируется [(playground)](https://go.dev/play/p/EAMjZgNOB6J)
[^8]. Всё дело в несовпадении типа аргумента `buf[:n]` и типа параметра функции
[ParseUint](https://pkg.go.dev/strconv#ParseUint), `byte-slice` и [string](https://go.dev/ref/spec#String_types) соответственно. Функции пакета `strconv`
(и `ParseUint` в том числе) предназначены для обработки строк, но не слайсов
байт, даже название намекает.

Для того чтобы понять что делать дальше, нужно погуглить [ref/spec](https://go.dev/ref/spec) по ключевым словам `slice`, `string`, `convertion`.
И в Go есть механизм,
позволяющий _изменить_ исходный тип данных на другой, механизм этот называется
[Type Conversions](https://go.dev/ref/spec#Conversions). Синтаксис одинаков
для всех пар типов `Type(Expression)`, процесс будет отличаться от пары к паре (если он вообще есть).
Необходимое нам правило есть в языке:

> Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.

Концертация слайса-байт в строку _выращивает_ строку байты которой есть элементы слайса. Даём байты получаем строки, то что нужно, воспользуемся им:

```diff
- v, err := strconv.ParseUint(buf[:n], 10, 64)
+ v, err := strconv.ParseUint(string(buf[:n]), 10, 64)
```

Это быстрый и корректный код. Хм, а быстрый ли? Ну, с точки зрения
производственной среды - да, он ведь не светится как ёлка в отчете
профилировщика, но я не писал бы статью если бы хотел рассказать что-то
полезное, гарольд. Я намеренно не привожу бенчмарки сфеерических примеров в
вакууме, потому что оптимизацией нужно заниматься не на основе результатов
бенчмарков, а на основе отчётов профайлера с работающих приложений.

Но вопрос остаётся. Так насколько быстрый это код? Делает ли он лишние вычисления? Что он вообще делает?

Хотя правило и не говорит о реализации, оставляя пространство для оптимизации
в будущем, что правильно, мы вольны изучать реализацию. Реализации кстати может и не
быть, либо правильнее сказать будет частью компилятора, а не рантайма. // туду

Если вспомнить что слайсы-байт являются изменяемыми структурами данных, а строки - нет, то
возникает вопрос - а как превратить изменяемую структуру данных в неизменяемую?

Если зажать Ctrl и кликнуть на `ParseUint` мы попадём[^12] на реализацию функции `ParseUint`. Но точно такой-же
клик на строку `string` приводит нас в файл `builtin.go` и документация к пакету говорит:

> The items documented here are not actually in package builti

Если тут нет искать нужно в другом месте. Другой вариант это посмотреть
на готовую программу и дизассеблировать её. Или ещё лучше попросить
компилятор сгенерировать промежуточное ассемблерное представление, а
не исполняемый файл

Самый простой способ это посмотреть изучив вывод инструмента `go build -gcflags=-S`[^11].
Выводит много информации, которая сейчас нам не интересна, нас интересует только момент вызова функции
`strconv.ParseUint` и вычисление её аргументов, даже я бы сказал вычисление первого аргумента - строки.

```asm
	MOVL	$10, CX ; Положить число 10 в регистр C
	MOVL	$64, DI ; Положить число 64 в регистр D
	CALL	strconv.ParseUint
```

Строка это струтура с двумя полями, указатель на первый байт строки и длина
строки в байтах. Функция `strconv.ParseUint` принимает 3 агрумента. Строку,
основание системы счисления и разрядность числа. Итого `strconv.ParseUint` будет
ждать в регистрах `AX/BX/CX/DI` указатель на первый байт строки, длину строки,
основание системы счисления и разрядность числа соответственно.

Второй и третий аргумент это простые константы[^10], и как мы видим, в регистры `CX` и `DI` помещаеюся числа `10` и `64`:

А вот в регистры `AX` и `BX` компилятор предполагает поместить указатель
на строку, на сами данные, нижелещащий массив и длину соответственно.

Но для это сначала строку нужно получить, поэтому компилятор вставляет вызов
функции `slicebytetostring`, которая и преобразует слайс байт в строку. Эта функция
рантайма и её можно найти в пакете `runtime`.

Без некоторых лишних деталей её реализация выглядит так:

```go
func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) {
	var p unsafe.Pointer
	if buf != nil && n <= len(buf) {
		p = unsafe.Pointer(buf)
	} else {
		p = mallocgc(uintptr(n), nil, false)
	}
	stringStructOf(&str).str = p
	stringStructOf(&str).len = n
	memmove(p, unsafe.Pointer(ptr), uintptr(n))
	return
}
```

Сначала мы проверяем выдали ли нам буфер куда мы поместим содержание строки,
если нет или длина буфера недостаточна рантайм выделит в куче пространство для
строки (да, компилятор не всегда может понять что объекту не нужно находиться в
куче, даже если это реально так).

- Потенциальная аллокация это раз.
- Вызов функции `memmove` копирующая участок памяти это два.

Наша задача не предполагает использоание старого значения слайса (число уже
распаршено и обработано) после завершения очередной итерации цикла, и, так же не предполагает
дальнейшее использование строки. Слайс байт мы можем переиспользовать явно, а что со строкой?

Но мы всё равно будем её конструировать, аллоцируя память (по необходимости),
копировать содержимое слайса в место выделенное под строку (безальтернативно).
И так на каждой итерации. Мы можем нагружаем рантайм бесполезной работой,
на работу аллокатора требуется CPU, на отслеживание выделенных объектов и их
дальнейшее освобождение сборщиком мусора так же тратит ресурсы CPU[^1].

## Чсть 2

Мы удовлетворяем требованиея типа параметра функции `strconv.ParseUint` и более нам
не нужно значение типа `string`. Отсюда вытекает наше предположение, а можем
ли мы попробовать не вызывать функцию slicebytetostring? Не использовать
синтаксическую конструкцию `string(X)`. Как ещё можно преобразовать один тип
в другой? Читатель может сказать что строки и слайсы байт похожи по структуре
в памяти. И можно ли заставить компилятор интерпретировать некоторый участок
памяти выделенный под байт-слайс как строку.

А похожи ли? Для начала можем посмотреть их представление в языке. Обьявление типов находятся в пакете runtime:

```go
// runtime/slice.go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}

// runtime/string.go
type stringStruct struct {
	str unsafe.Pointer
	len int
}
```

Слайс это структура с тремя полями - `unsafe.Pointer`, `int`, `int`. `unsafe.Pointer`
это указатель на произвольный тип (что такое тут не важно):

```go
type Pointer *ArbitraryType // type ArbitraryType int
````

Указатель на 64-битной системе это 8 байт. Два int это ещё 16 байт. Итого 24
байта на слайс. Строка это два поля `unsafe.Pointer` и `int` всего 16 байт. Как
видим размеры не сходятся. Как минимум манипуляции со сзначениями полей `array/
str` мы можем привести к тому чтобы указывать на одну и ту же область памяти.
Это будет работать потому что строки в Go это просто последовательности байт,
то есть - `[...]uint8`, это не обязательно закодированные в чем-либо _символы_.
Запомним это. Ещё мы видим что поле len, находится по одном и том же месте.
Поэтому если заставить посмотреть на участок памяти принадлежащий слайсу как на
строку мы увидим именно строку.

Наш полигон:

```go
func foobar () {
	a := "foobar"
	b := []byte(string(foobar))

	// ...
}
```

Посмотрим на реальные значения. Ниже представлена открытая сессия dlv отладчика. На стекфрейме
есть две локальные переменные `a` и `b`, `а` это строка, `b` - это слайс-байт
(`uint8` это подтип типа `byte`):

```delve
(dlv) locals
  a = "foobar"
  b = []uint8 len: 6, cap: 12, [...]
```

Значение строки нам показывают, значение слайса-байт мы не видим, указывается
только длина и ёмкость. Не очень понятно что это на самом деле. Роем дальше.
Адреса значений можно получить так:

```delve
(dlv) print unsafe.Pointer(&a)
  (unsafe.Pointer)(0x14000114e80)

(dlv) print unsafe.Pointer(&b)
  (unsafe.Pointer)(0x14000114ea0)
```

Так, как мы уже видели выше строка это указатель и int. Указатель 8 байт и int 8 байт. Восемь плюс восемь будет -88- 16.
Вычитываем 16 байт начиная с адреса переменной `a`:

```delve
(dlv) x -fmt hex -count 16 0x14000114e80
	0x14000114e80:   0xd0   0x8f   0x6a   0x00   0x01   0x00   0x00   0x00
	0x14000114e88:   0x06   0x00   0x00   0x00   0x00   0x00   0x00   0x00
```

Моя машина - little-endian[^13], по младшему адресу `0x14000114e80` хранится младший байт
указателя на строку, в `0x14000114e87` старший байт указателя. По адресу `0x14000114e88`
находится младший байт значения длины, по адрему `0x14000114e9f` будет старший
байт поля `len`. Чтобы отобразить их в человекопонятном виде нужно выписать
зачения без пробелов задом наперёд (так как мы, люди, привыкли ставить старший разряд
левее младшего, а не наоборот). Или попросить `delve` отобразить значение с учётом размера,
размер при этом нужно указать самостоятельно:

```delve
(dlv) x -fmt hex -size 8 -count 2 0x14000114e80
	0x14000114e80:   0x00000001006a8fd0   0x0000000000000006
```

Первые 8 байт это указатель на строку, по нему тоже можно пройтись и посмотреть что там лежит:

```delve
(dlv) x -fmt hex -count 6 0x00000001006a8fd0
  0x1006a8fd0:   0x66   0x6f   0x6f   0x62   0x61   0x72 // f o o b a r -> foobar
```

Судя по документации delve не поддерживает формат char или что-то вроде того, так что декодируйте в уме.

Так хорошо, со строками разобрались, а что из себя представляет байт слайс?

```delve
(dlv) x -fmt hex -count 16 0x14000114ea0
  0x14000114ea0:   0x44   0x4e   0x11   0x00   0x40   0x01   0x00   0x00
  0x14000114ea8:   0x06   0x00   0x00   0x00   0x00   0x00   0x00   0x00
```

Так, тоже адрес и длина. Строго говоря там ещё есть ёмкость:

```delve
(dlv) x -fmt hex -size 8 -count 3 0x14000114ea0
  0x14000114ea0:   0x0000014000114e44   0x0000000000000006   0x000000000000000c
```

Идея заключается в том, что мы можем сказать компилятору, на самом деле, в этом
участке памяти лежит не слайс, там лежит строка. Что если попробовать взять
адрес в памяти местонахождения слайса байт, далее сказать что указывает этот
указатель не на слайс, а на строку.  На помощь придет всё та же конверсия типов.
А перед использованием строки, разименовть указатель.

Давайте ещё раз:

```delve
(dlv) x -fmt hex -size 8 -count 2 0x14000114ea0
  0x14000114ea0:   0x0000014000114e44   0x0000000000000006
```

Вы можете ответить на вопрос, это строка тут лежит или слайс байт? На этот вопрос
ответить нельзя.

```go
buf := []byte{'H', 'e', 'l', 'l'}
pointerToByteSlice := unsafe.Pointer(&buf)
pointerToString := (*string)pointer
str := *pointerToString
fmt.Printf("val=%q type=%T\n", str, str) // val="Hell" type=string
```

Всё это наводит на мысль что мы можем представить слайс-байт как строку. Если
попытаться обмануть компилятор, то он ничего не заметит. Сломать систему типов
может быть сложно, но не в Go. Вероятно каждый хоть раз видел импортированный
пакет "unsafe".

```
The built-in package unsafe, known to the compiler and accessible through the
import path "unsafe", provides facilities for low-level programming including
operations that violate the type system.
```

Кажется слова _нарушение системы типов_ и есть те заветные слова что мы ищем.

```
A Pointer is a pointer type but a Pointer value may not be dereferenced. Any
pointer or value of underlying type uintptr can be converted to a type of
underlying type Pointer and vice versa.
```

Так, то есть это предложение, в том числе, гооврит нам о том, что любой
указатель может быть преобразован в тип _underlying type_ которого Pointer,
_underlying type_ Pointer тоже `Pointer`:

- Взять значение слайса-байт (это базовый тип).
- Взать указатель на это значение (эти будет указатель).
- Преобразовать указатель в `Pointer`.
- Преобразовать `Pointer` в указатель на строку.

Далее разыменовать указатель на строку и получить строку. (вопрос на
самостоятельное изучение, что станет с 8 байтами в которых хранился емкость
когда заголовок строки будет собран сборщиком мусора, представте что заголовок
хранится в куче, не на стеке горутины).

Первые 8[^9] байт и там и там содержат указатель на сами данные. Компилятор не
переупорядочивает в памяти хранимые поля структуры. Поэтому можно взять кусок
памяти в котором хранится слайс и сказать, это строка.

Когда рантайм пойдёт брать длину строки, так так же отсчитает 8 байт от начала и
прочитает 8 байт где найдёт длину строки. А когда возьмёт 8 байт начиная с 0, он
обнажит адрес, по которому лежат байты нашей строки. Как мы видели в реализации
функции `slicebytetostring` содержимое слайса байт не проходит никакой обрабокт
(например проверки что последовательность это валидация последовательность udf-
8 символов).

Однострочная версия версия:

```
buf := []byte{'H', 'e', 'l', 'l'}
v, err := strconv.ParseUint(*(*string)(unsafe.Pointer(&buf)), 10, 64)
check(err)

fmt.Println(v) // Hell
```

Почему мы вообще используем пакет `unsafe`, так это потому, что нет
правила конверсии указателя на байт слайс в указатель на строку. Но есть
правило конверсии указателя на слайс в `unsafe.Pointer` и правило конверсии
`unsafe.Pointer` в указатель на строку. Как-то так:

```
(*string)(&buf)                 // Cannot convert an expression of the type '*[]byte' to the type '*string'
(*string)(unsafe.Pointer(&buf)) // This is fine 🔥
```

Что мы молучаем в итоге. Вызов функции `slicebytetostring`, потенциальную аллокацию и копирование
заменено взятием адреса и разыменованием:

```asm
  MOVQ  32(SP),  AX     ; Взять адрес и положить в AX
  MOVQ  AX,      24(SP) ; Сохранить адрес в SP по смещению 24
```

## Чсть 3

> _Ты перечислял неизменяемые типы, но почему не упомянул строки?_

Если мы можем конвертировать `[]byte` в `string`, значит можем и обратно? Переиспользование участа памяти под слайс Выглядит что так, действуем по аналогии:

```go
type socket struct {}

func (socket) ReadFrom(dst []byte) (n, error) {
	return copy(dst, []byte{70, 71, 72}), nil
}

func main() {
	s := socket{}

	buf := [3]byte{}
	for {
		n, err := s.ReadFrom(buf[:])
		check(err)

		v, err := strconv.ParseUint64(buf[:n], 10, 64)
		check(err)

		fmt.Print(v)
	}
}
```

Документация говорит что нет:

> Strings are immutable: once created, it is impossible to change the contents of a string.

И если проверить, то с первого взгляда, так оно и есть:

```
here := "Hello, Go!"
here[0] = 1 // Compile time error: Cannot assign to here[0]
```

Менять содержимое строки недаёт ещё даже компилятор. А если попробовать обмануть?

---

- Ты когда нибудь `Segmentation Fault` на Go видел? И я не видел, а он - есть [^2]:

---

Идея в том, что мы создадим `Slice` шарящий нижележащий массив вместе со строкой, слайсы менять компилятор позволит.

```go
package main

import "unsafe"

func main() {
	s := "Hello, Go!"
	b := *(*[]byte)(unsafe.Pointer(&s))
	b[0] = 'X' // unexpected fault address 0x100ebfe77
}
```

Не получилось, не фартануло. Компилятор скомпилировал, но ошибка (фатальная) уже
при исполнении. Это вполне способно разбудить вас ночью, но мы пойдём дальше.

А если так, кто в Text Segment не спрятался, я не виноват:

```go
package main

import (
	"unsafe"
	"fmt"
)

func main() {
	s := string([]byte("Hello, Go!"))
	b := *(*[]byte)(unsafe.Pointer(&s))
	b[0] = 'X'

	fmt.Println(s) // Xello, Go!
}
```

Это работает, гарольд. Получается что не все строки в программе такие уж и
неизменяемые, некоторое подмножество строк живущих в программе изменить можно,
[Playground](https://go.dev/play/p/YeZAO4Mhmdy). Изменемы те, кто живёт в куче,
не изменяемы те, что живет в коде программы [^5].

Трололо [версия](https://go.dev/play/p/MNwXW4k9wxw), нужно запомнить фотографически:

```go
package main

import (
	"unsafe"
	"fmt"
	"strings"
)

func main() {
	buf := strings.Builder{}
	buf.WriteString("Go strings are immutable")

	out := buf.String()

	doit(out) // Очевидно ничего плохого со строкой не сделает.

	fmt.Println(out) // Go strings are mutable
}

func doit(s string) {
	b := *(*[]byte)(unsafe.Pointer(&s))

	for i := 0; i < 7; i++ {
		b[15+i] = b[17+i]
	}

	b[len(b)-2] = ' '
	b[len(b)-1] = ' '
}
```

Хиханьки-хаханьки заканчивается когда мы вспонимаем, что байт слайсы изменяемый
тип данных. Например, мы можем растянуть байт слайс до его емкости. Так стоп, а
какая вообще ёмкость у получившегося слайса?

```go
package main

import (
	"unsafe"
	"fmt"
)

func main() {
	here := "Hello "
	here = string([]byte(here))

	out := *(*[]byte)(unsafe.Pointer(&here))

	fmt.Printf("%d %d\n", len(out), cap(out)) // 6 96
}
```

Емкость равна 96, шести не равно, ответы 0, 6 и 42 пояснения не требуют, но 96?

Если вы запустите код на своей машине, вывод может быть другим, но точно можно
сказать, что он не всгда равен длине строки. Пробуем растянуть слайс:

```go
package main

import (
	"unsafe"
	"fmt"
)

func main() {
	here := "Hello " // <<
	here = string([]byte(here))

	out := *(*[]byte)(unsafe.Pointer(&here))
	out = out[:96]
	fmt.Printf("%d %d\n", len(out), cap(out)) // "Hello  @�!@HelloO@"
}
```

За ним определённо что-то есть.

> TODO: Рассказ откуда взяолсь значение 96 и сколько там может быть.

Представим что пользователь определяет сколько он может ещё получить данных. Но
не очень много чтобы не перегрузить сервер. Мы пишем надёжное и безопасное ПО?

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	here := "Hello " // <<
	here = string([]byte(here))

	func() {
		secretparol := string([]byte("lolkekcheburek")) // Секретное преобразование для секретного пароля
		secretparol += ""
	}()

	out := *(*[]byte)(unsafe.Pointer(&here))

	fmt.Printf("%d %d\n", len(out), cap(out))

	fmt.Println(string(out))
	out = out[:1000000]      // Где-то там, далеко далеко, есть пароль.
	fmt.Println(string(out))
}
```

Полный вывод:

```
6 1374389815144
Hello
Hello �!@("@(�  @Hello Ў        @Ў      @�zp@�sP:�s
@$@@�!@`)��     @��     @�      @�      @`      @�      @ !     @@��!@�&@@@�@�@��
          ����r �����AQ�"���hdA�I8��hd�r        ��hd�r  ���cr�9�Z�@����r       �����AQ�"���hdA�I8��hd�r        ��hd�r  ���cr�9�
@p
@1374389815144.lolkekcheburekhG@6 Hello // ТУТ КАЖЕТСЯ ПАРОЛЬ
89815144
Hello ��px`
@f�f��0�`@0`@�@ �@
���l�r@@``@ �@�`@�`@x�@ H�@ a@
u*���(*�@�@�@�@0�@
@�@               @

  xY�\�@�`@`�P@/Users/rokkerruslan/w/secret.maxfilesperprocIp // Так, а это что такое?
@
```

Кончились хиханьки-хаханьки. Не смотрите что в выводе много лишней информации,
пароли и другие секретный последовательности обычно отличаются от строк в
программе, их легко определить. А некоторые строки вообще по структуре можно
искать, примерно так выглядят все AccessKeyID от AWS - `AKETOJOPAGANDAMSTYLE`.

Если вам кажется что это нереалистичный сценарий, то всё таки кажется. У этого
типа ошибок своё название есть - [Buffer Overflow](https://en.wikipedia.org/wiki/Buffer_overflow), кому-то они могут стоит денег.

Подумаем. Программа может:
- Упасть с ошибкой `Segmentation Fault`, если так выйдёт что при чтении
из слайса мы выйдем из границы адресного пространства выледелнного нам ОС.
Программа завершается. И это самое безобидное из всех возможный ситуаций.
- Как показано выше, атакующий может вычитать область памяти, в которой в свою очередь
может присутствовать чувствительная информация, явки/пароли из стека горутипы и
стека других горутин в программе. И всё содержимое памяти процесса.
- Атакующий может изменить чужую область памяти на своё значение. Например, если он знает по
какому смещению живёт оригинал пароля, то может его подеменить своим.

## Часть 4. "Правильный способ"

В Go есть "правильный" (звучит так себе, лучше скажем _более безопасный_)
способ преобразовать строку в слайс и обратно, без аллокации и копирования
нижележащего массива (но будте внимательны, спать нельзя даже тут, потому что и
в его использовании можно накосячить [^4]).

Идея заключается в том, что мы конструируем заголовки (и строки и байт-слайса)
самостоятельно и копируем поля из структуры из которой мы преобразовываем в
только что созданную структуру.

Подход не отличается концептуально, unsafe остался, формально осталось и
нарушение системы типов, ведь reflect.SliceHeader это не runtime.slice. Если их
представление в памяти не будет совпадать, то будет плохо.

```go
func btos(in []byte) (out string) {
	slice := (*reflect.SliceHeader)(unsafe.Pointer(&in))
	str := (*reflect.StringHeader)(unsafe.Pointer(&out))
	str.Data = slice.Data
	str.Len = slice.Len

	return s
}

func stob(in string) (out []byte) {
	slice := (*reflect.SliceHeader)(unsafe.Pointer(&out))
	str := (*reflect.StringHeader)(unsafe.Pointer(&in))
	slice.Data = str.Data
	slice.Len = str.Len
	slice.Cap = str.Len

	return s
}
```

Но мы больше не интерпретируем блок памяти от заголока слайса как блок памяти
заголовка строки. Мы создаём новый заголовок для слайса байт, а далее заполняем
его поля руками. Более ли этот подход устойчивее к ошибка, да, он более утойчив
(нужно упомянуть, вы создаёте новый объект, вы не можете указать компилатору не
аллоцировать объект в/на куче).

Сложность и изначальное представление строк, как неизменяемых типов, приводит
к тому что функциональности конверсии (без выделения памяти и копирования) нет
в стандарной библиотеке Go, по крайней мере, это так со [слов разработчиков](https://github.com/golang/go/issues/25484#issuecomment-390846454).

Так же проблема состоит в том, что язык Go, а именно компилятор языка, не
подталкивает вас к правильному решению [^3], ему и с конверсией `*string ->
unsafe.Pointer -> *[]byte` живётся хорошо. Для компилятора это одинаковые
способы. Корректную работу должен обеспечить программист. Кот с `unsafe` должен
содержать пояснение, что результат работы корректен и не противоречив.

## Заключение

Заключения нет. ДОСВИДАНИЯ.

[^7]: Кроме первой. Но я больше так не буду, das verspreche ich. Нажмите на обратную стрелку расположенную сразу за текстом, чтобы вернуться на место сноски в тексте.

[^1]: Конкретно в этом случае строка убегать в кучу не будет и из не необходымых операций у нас останется только копирование, место для строки тоже выделено на стекфрейме функции `handle`. В Go существуют некоторые оптимизации (одна из них https://go-review.googlesource.com/c/go/+/3120). В более сложном коде, компилятор может не быть настолько проворным.

[^2]: На самом деле, это довольно распространённая ошибка. Чаще всего её встретить можно при разименовании `nil` указателя, когда забыли инициализировать поле структуры или что-то в этом роде.

[^3]: Весь код с статье, который в принципе компилируется, не выдаёт ошибок на проверке go vet.

[^5]: TODO: Виды памяти в программе.

[^4]: Нельзя явно создавать инстансы этих структур, только конвертировать из строк/байт-слайс. Более подробно в комментарии к методу [unsafe.Pointer](https://pkg.go.dev/unsafe#Pointer), пункт номер 6.

[^8]: Разбиение потока на отдельные сообщения или по другому - [message framing](https://blog.stephencleary.com/2009/04/message-framing.html), мы оставим за бортом. Предположим что одна операция чтения возвращает одно сообщение, которое в свою очередь содежит одно число и оно точно поместится в 128 байт.

[^9]: 8 байт на 64-битной системе.

[^10]: В Go недвно изменили способ передачи аргументов в функции. Как видите сейчас на amd64 они передаются через регистры, первый (слева направо в сигнатуре функции) аргумент через регистр AX, второй и третий через CX и DI соответственно. Описание того как передаются аргументы называется Calling Conversion, тут вы можете ознакомиться подробнее https://tip.golang.org/src/cmd/compile/abi-internal.

[^11]: Мы не будем подробно останавливаться в статье на Go ассемблере, Его знание не играет роли для понимания статьи, `MOVL $1, AX` - если вы можете понять что это _копирование_ значения _один_ в регистр `AX`, этого достаточно. Если же нет, вы можете прочитать [A Quick Guide to Go's Assembler
](https://go.dev/doc/asm).

[^12]: Если вы как и я из поколения IDE. Если нет, то вы и сами знаете как найти.

[^13]: Порядок байт.
